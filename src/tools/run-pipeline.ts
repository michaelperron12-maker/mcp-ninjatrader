import { handleGenerateScript } from './generate-script.js';
import { handleUpdateCode } from './update-code.js';
import { handleAuditScript, type AuditResult } from './audit-script.js';
import { handleTestCompilation, type CompilationResult } from './test-compilation.js';
import { handleDeliverScript } from './deliver-script.js';

export function handleRunPipeline(params: {
  description: string;
  type?: string;
  instrument?: string;
  timeframe?: string;
  auto_fix?: boolean;
}): { content: Array<{ type: 'text'; text: string }> } {
  const { description, type, instrument, timeframe, auto_fix = true } = params;

  const stages: string[] = [];
  let currentCode = '';

  // ═══════════════════════════════════════════
  // STAGE 1: GENERATE
  // ═══════════════════════════════════════════
  stages.push('## Étape 1: Génération du script');

  const genResult = handleGenerateScript({ description, type, instrument, timeframe });
  const genText = genResult.content[0].text;

  stages.push(`Le contexte de génération a été assemblé avec succès.`);
  stages.push(`Le knowledge base NT8 (22 patterns + scripts de référence) est prêt.`);
  stages.push('');
  stages.push('**IMPORTANT**: Claude doit maintenant générer le code C# en utilisant le contexte ci-dessous.');
  stages.push('Une fois le code généré, utilisez les outils `update_code`, `audit_script`, `test_compilation` et `deliver_script` séquentiellement pour valider et livrer le script.');
  stages.push('');

  // Build pipeline output
  let output = `# Pipeline de Génération NinjaTrader 8\n\n`;
  output += `## Demande\n\n`;
  output += `- **Description**: ${description}\n`;
  output += `- **Type**: ${type || 'auto-détecté'}\n`;
  if (instrument) output += `- **Instrument**: ${instrument}\n`;
  if (timeframe) output += `- **Timeframe**: ${timeframe}\n`;
  output += `- **Auto-fix**: ${auto_fix ? 'Oui' : 'Non'}\n\n`;
  output += `---\n\n`;

  for (const stage of stages) {
    output += stage + '\n';
  }

  output += `\n---\n\n`;

  // Include the full generation context
  output += genText;

  output += `\n\n---\n\n`;
  output += `## Prochaines étapes après génération du code\n\n`;
  output += `1. **update_code**: Passe le code généré pour vérifier les best practices\n`;
  output += `2. **audit_script**: Audite le code (12 checks: Brush, anti-doublon, MTF, etc.)\n`;
  output += `3. **test_compilation**: Test statique de compilation\n`;
  output += `4. **deliver_script**: Sauvegarde le .cs final + guide d'installation\n\n`;
  output += `Appelez ces outils séquentiellement avec le code généré.\n`;

  return {
    content: [{ type: 'text', text: output }]
  };
}

/**
 * Validates code through update -> audit -> test -> deliver pipeline.
 * Called after code has been generated by Claude.
 */
export function handleValidateAndDeliver(params: {
  code: string;
  name: string;
  type: string;
  description: string;
  auto_fix?: boolean;
}): { content: Array<{ type: 'text'; text: string }> } {
  const { code, name, type, description, auto_fix = true } = params;
  const report: string[] = [];

  // STAGE 2: UPDATE
  report.push('# Rapport de Validation Pipeline\n');
  report.push('## Étape 2: Mise à jour Best Practices\n');

  const updateResult = handleUpdateCode({ code, script_type: type });
  const updateText = updateResult.content[0].text;

  // Extract updated code from the result
  const codeMatch = updateText.match(/```csharp\n([\s\S]*?)```/);
  let updatedCode = codeMatch ? codeMatch[1] : code;

  const changeCount = (updateText.match(/###/g) || []).length;
  report.push(`${changeCount} corrections appliquées.\n`);

  // STAGE 3: AUDIT
  report.push('## Étape 3: Audit de Qualité (12 checks)\n');

  let auditResult = handleAuditScript({ code: updatedCode, auto_fix });
  let audit = auditResult.auditResult;

  // Auto-fix and re-audit if needed
  if (auto_fix && audit.fixedCode) {
    updatedCode = audit.fixedCode;
    report.push('Auto-corrections appliquées. Re-audit...\n');
    auditResult = handleAuditScript({ code: updatedCode, auto_fix: false });
    audit = auditResult.auditResult;
  }

  const errors = audit.issues.filter(i => i.severity === 'ERROR').length;
  const warnings = audit.issues.filter(i => i.severity === 'WARNING').length;
  report.push(`Statut: **${audit.status.toUpperCase()}** — ${errors} erreurs, ${warnings} avertissements\n`);

  if (audit.issues.length > 0) {
    for (const issue of audit.issues) {
      report.push(`- [${issue.severity}] ${issue.message}`);
    }
    report.push('');
  }

  // STAGE 4: TEST COMPILATION
  report.push('## Étape 4: Test de Compilation Statique\n');

  const testResult = handleTestCompilation({ code: updatedCode });
  const test = testResult.testResult;

  report.push(`Statut: **${test.status.toUpperCase()}** — ${test.errors.length} erreurs, ${test.warnings.length} avertissements\n`);

  if (test.errors.length > 0) {
    for (const err of test.errors) {
      report.push(`- [ERREUR] ${err.message}`);
    }
    report.push('');
  }
  if (test.warnings.length > 0) {
    for (const warn of test.warnings) {
      report.push(`- [AVERT] ${warn.message}`);
    }
    report.push('');
  }

  // STAGE 5: DELIVER (only if no compilation errors)
  if (test.status !== 'fail') {
    report.push('## Étape 5: Livraison\n');

    const deliverResult = handleDeliverScript({
      code: updatedCode,
      name,
      type,
      description,
      metadata: {
        updateChanges: [],
        auditResult: audit,
        testResult: test,
        pipelineStatus: test.status === 'pass' && audit.status !== 'fail' ? 'pass' : 'warn'
      }
    });

    report.push(deliverResult.content[0].text);
  } else {
    report.push('## Livraison annulée\n');
    report.push('Le script contient des erreurs de compilation. Corrigez les erreurs ci-dessus et réessayez.\n');
    report.push(`\n## Code actuel (avec erreurs)\n\n\`\`\`csharp\n${updatedCode}\n\`\`\`\n`);
  }

  return {
    content: [{ type: 'text', text: report.join('\n') }]
  };
}
